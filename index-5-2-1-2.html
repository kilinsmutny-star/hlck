<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0057b7">
    <meta name="application-name" content="Survive">

    <!-- Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Survive">
    <link rel="apple-touch-icon" href="icon-192.png">

    <!-- Windows -->
    <meta name="msapplication-TileImage" content="icon-192.png">
    <meta name="msapplication-TileColor" content="#0057b7">

    <title>Fall for Ukraine ‚Äì Survive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 10px;
    overflow-x: hidden;

    /* Ukraine inspired gradient */
    background: linear-gradient(
        180deg,
        #0057b7 0%,      /* deep blue */
        #003b7a 40%,
        #111827 60%,     /* dark military tone */
        #ffd700 100%     /* yellow accent */
    );
}
        .game-container {
    background: rgba(15, 23, 42, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 20px;
    box-shadow: 
        0 0 40px rgba(0, 87, 183, 0.5),
        0 0 80px rgba(255, 215, 0, 0.2);
    max-width: 950px;
    width: 100%;
    border: 1px solid rgba(255,255,255,0.1);
}

       h1 {
    text-align: center;
    color: #ffd700;
    margin-bottom: 20px;
    font-size: 26px;
    letter-spacing: 2px;
    text-transform: uppercase;
    font-weight: 700;
}

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 14px;
            color: #94a3b8;
            font-weight: bold;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: inline-block;
            padding: 8px 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .file-input-label:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button {
    padding: 10px 20px;
    background: linear-gradient(90deg, #0057b7, #003b7a);
    color: white;
    border: 1px solid #ffd700;
    border-radius: 8px;
    cursor: pointer;
    font-size: 15px;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(0,87,183,0.5);
}

button:hover {
    background: linear-gradient(90deg, #003b7a, #0057b7);
    transform: translateY(-2px);
    box-shadow: 0 0 15px rgba(255,215,0,0.6);
}

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
            position: relative;
        }

        .stat-item::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ffd700, transparent);
        }

        .stat-label {
            font-size: 11px;
            color: #94a3b8;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 22px;
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .health-bar-container {
            width: 100%;
            min-height: 44px;
            background: transparent;
            margin-bottom: 15px;
            border: none;
            box-shadow: none;
            position: relative;
            display: flex;
            align-items: center;
            gap: 0;
            padding: 4px 0;
        }

        .hp-orbs-row {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap;
        }

        .hp-orb-wrap {
            position: relative;
            width: 36px;
            height: 36px;
        }

        /* Empty orb shell */
        .hp-orb-bg {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: #222;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.6);
            overflow: hidden;
        }

        /* Fill layer clipped from bottom */
        .hp-orb-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%; /* set by JS */
            transition: height 0.3s ease;
            overflow: hidden;
            border-radius: 50%;
        }

        /* Pepsi red top */
        .hp-orb-fill::before {
            content: '';
            position: absolute;
            left: 0; right: 0; top: 0;
            height: 50%;
            background: #e8162a;
        }
        /* Pepsi blue bottom */
        .hp-orb-fill::after {
            content: '';
            position: absolute;
            left: 0; right: 0; bottom: 0;
            height: 50%;
            background: #004b93;
        }

        /* White Pepsi wave */
        .hp-orb-wave {
            position: absolute;
            left: -15%;
            width: 130%;
            top: 42%;
            height: 18%;
            background: white;
            border-radius: 50%;
            z-index: 2;
            pointer-events: none;
        }

        /* Orb border ring */
        .hp-orb-ring {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.85);
            box-shadow: 0 0 8px rgba(0,75,147,0.6);
            pointer-events: none;
        }

        /* HP label */
        .hp-label {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            margin-left: 8px;
            text-shadow: 1px 1px 3px #000;
            white-space: nowrap;
        }

        #gameCanvas {
    border: 3px solid #ffd700;
    border-radius: 15px;
    display: block;
    margin: 0 auto;
    background: radial-gradient(circle at center, #1f2937, #0f172a);
    cursor: crosshair;
    box-shadow: 
        0 0 25px rgba(0,0,0,0.8),
        inset 0 0 50px rgba(0,0,0,0.3);
    position: relative;
}

        /* Fullscreen styles */
        .game-container.fullscreen {
            padding: 0;
            margin: 0;
            max-width: 100%;
            width: 100vw;
            height: 100vh;
            background: #000;
            border-radius: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            overflow: hidden;
        }

        .game-container.fullscreen .stats,
        .game-container.fullscreen .health-bar-container,
        .game-container.fullscreen #gameCanvas,
        .game-container.fullscreen .mobile-controls {
            display: flex !important;
        }

        .game-container.fullscreen > *:not(.stats):not(.health-bar-container):not(#gameCanvas):not(.mobile-controls) {
            display: none !important;
        }

        .game-container.fullscreen .stats {
            width: 100%;
            max-width: 100vw;
            margin: 0;
            padding: 6px 10px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 0;
            border: none;
            border-bottom: 1px solid rgba(255,215,0,0.3);
            flex-shrink: 0;
        }

        .game-container.fullscreen .stats .stat-value {
            font-size: 16px;
        }

        .game-container.fullscreen .stats .stat-label {
            font-size: 9px;
        }

        .game-container.fullscreen .health-bar-container {
            width: 100%;
            max-width: 100vw;
            margin: 0;
            min-height: 0;
            padding: 3px 8px;
            border-radius: 0;
            border: none;
            border-bottom: 1px solid rgba(255,215,0,0.2);
            flex-shrink: 0;
            background: rgba(15,23,42,0.85);
        }
        .game-container.fullscreen .hp-orb-wrap {
            width: 24px;
            height: 24px;
        }
        .game-container.fullscreen .hp-label {
            font-size: 10px;
        }

        .game-container.fullscreen #gameCanvas {
            display: block !important;
            flex: 0 0 auto;
            border: none !important;
            border-radius: 0;
            margin: 0 auto !important;
            align-self: center;
        }

        /* Portrait mobile fullscreen */
        @media (orientation: portrait) {
            .game-container.fullscreen {
                align-items: center;
                justify-content: flex-start;
            }
            .game-container.fullscreen #gameCanvas {
                width: 100vw !important;
                height: auto !important;
                max-width: 100vw;
            }
        }

        /* Landscape fullscreen */
        @media (orientation: landscape) {
            .game-container.fullscreen {
                align-items: center;
                justify-content: center;
            }
            .game-container.fullscreen #gameCanvas {
                width: auto !important;
                height: calc(100vh - 80px) !important;
                max-width: 100vw;
            }
        }

        .game-over {
            display: none;
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
            color: white;
            border-radius: 15px;
            margin-top: 20px;
            border: 2px solid #ef4444;
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
        }

        .game-over h2 {
            color: #ef4444;
            margin-bottom: 20px;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
            letter-spacing: 2px;
        }

        .game-over p {
            font-size: 18px;
            margin: 10px 0;
            color: #94a3b8;
        }

        .game-over p span {
            color: #ffd700;
            font-weight: bold;
            font-size: 22px;
        }

        .name-input {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        .name-input input {
            padding: 10px 15px;
            border: 2px solid #ffd700;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            font-size: 16px;
            outline: none;
            min-width: 200px;
        }

        .name-input input:focus {
            border-color: #10b981;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }

        .name-input button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            border: 2px solid #10b981;
        }

        .name-input button:hover {
            background: linear-gradient(135deg, #059669, #10b981);
        }

        /* Leaderboard */
        .leaderboard {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.9));
            border-radius: 12px;
            border: 2px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .leaderboard h3 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .leaderboard-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin: 8px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid #ffd700;
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: translateX(5px);
        }

        .leaderboard-entry.top1 {
            border-left-color: #ffd700;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), rgba(0, 0, 0, 0.3));
        }

        .leaderboard-entry.top2 {
            border-left-color: #c0c0c0;
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.2), rgba(0, 0, 0, 0.3));
        }

        .leaderboard-entry.top3 {
            border-left-color: #cd7f32;
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.2), rgba(0, 0, 0, 0.3));
        }

        .leaderboard-rank {
            font-size: 20px;
            font-weight: bold;
            color: #ffd700;
            min-width: 40px;
        }

        .leaderboard-name {
            flex: 1;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
        }

        .leaderboard-score {
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            min-width: 100px;
            text-align: right;
        }

        .leaderboard-stats {
            color: #94a3b8;
            font-size: 12px;
            margin-left: 15px;
        }

        .leaderboard-empty {
            text-align: center;
            color: #94a3b8;
            padding: 40px;
            font-style: italic;
        }

        .game-over button {
            margin-top: 15px;
        }

        .instructions {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.8), rgba(30, 41, 59, 0.8));
            border-radius: 12px;
            font-size: 14px;
            color: #94a3b8;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .instructions h3 {
            margin-bottom: 15px;
            color: #ffd700;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .instructions strong {
            color: #fff;
        }

        /* Floating pause button for fullscreen/mobile */
        .floating-pause-btn {
            display: none;
            position: fixed;
            top: 12px;
            right: 12px;
            z-index: 400;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(99, 102, 241, 0.85);
            border: 2px solid #818cf8;
            color: white;
            font-size: 22px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: all 0.2s;
            backdrop-filter: blur(4px);
            padding: 0;
        }
        .floating-pause-btn.visible {
            display: flex;
        }
        /* Always show pause btn in fullscreen */
        .game-container.fullscreen ~ .floating-pause-btn,
        .game-container.fullscreen .floating-pause-btn {
            display: flex !important;
        }
        .floating-pause-btn:hover {
            background: rgba(79, 70, 229, 0.95);
            transform: scale(1.1);
        }
        .floating-pause-btn:active {
            transform: scale(0.95);
        }

        /* Pause overlay must work in fullscreen */
        .pause-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 500;
            align-items: center;
            justify-content: center;
        }
        .pause-overlay.show {
            display: flex;
        }
        .pause-menu {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
            border: 2px solid #ffd700;
            border-radius: 20px;
            padding: 40px 60px;
            text-align: center;
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.3);
            min-width: 300px;
        }
        .pause-menu h2 {
            color: #ffd700;
            font-size: 36px;
            letter-spacing: 4px;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }
        .pause-menu p {
            color: #94a3b8;
            font-size: 14px;
            margin-bottom: 30px;
        }
        .pause-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .pause-menu-buttons button {
            font-size: 16px;
            padding: 12px 30px;
            width: 100%;
        }
        .pause-btn-resume {
            background: linear-gradient(135deg, #10b981, #059669) !important;
            border-color: #10b981 !important;
        }
        .pause-btn-resume:hover {
            background: linear-gradient(135deg, #059669, #10b981) !important;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.6) !important;
        }
        .pause-btn-restart {
            background: linear-gradient(135deg, #ef4444, #dc2626) !important;
            border-color: #ef4444 !important;
        }
        .pause-btn-restart:hover {
            background: linear-gradient(135deg, #dc2626, #ef4444) !important;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.6) !important;
        }
        #pauseBtn {
            background: linear-gradient(90deg, #6366f1, #4f46e5);
            border-color: #818cf8;
        }
        #pauseBtn:hover {
            background: linear-gradient(90deg, #4f46e5, #6366f1);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.6);
        }

        .boss-warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.95);
            color: white;
            padding: 40px 60px;
            border-radius: 15px;
            font-size: 48px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            border: 4px solid #ff4b2b; 
        }

        .boss-warning.show {
            display: block;
            animation: pulse 0.5s ease-in-out 3;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        /* ‚îÄ‚îÄ Animations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700; }
            50%       { text-shadow: 0 0 25px #ffd700, 0 0 50px #ff8800, 0 0 80px #ff4400; }
        }
        h1 { animation: titleGlow 2.5s ease-in-out infinite; }

        @keyframes statPop {
            0%   { transform: scale(1); }
            40%  { transform: scale(1.35); color: #fff; }
            100% { transform: scale(1); }
        }
        .stat-value.popped { animation: statPop 0.35s ease-out forwards; }

        @keyframes gameOverIn {
            0%   { opacity:0; transform: scale(0.7) translateY(40px); }
            60%  { transform: scale(1.04) translateY(-5px); }
            100% { opacity:1; transform: scale(1) translateY(0); }
        }
        .game-over { animation: none; }
        .game-over.show { display: block; animation: gameOverIn 0.5s cubic-bezier(.22,1,.36,1) forwards; }

        @keyframes bossFlash {
            0%,100% { background: rgba(255,0,0,0.95); }
            50%      { background: rgba(180,0,0,0.95); box-shadow: 0 0 80px rgba(255,0,0,1); }
        }
        .boss-warning.show { animation: bossFlash 0.45s ease-in-out 3; }

        @keyframes diffBtnIn {
            from { opacity:0; transform: translateY(20px) scale(0.9); }
            to   { opacity:1; transform: translateY(0) scale(1); }
        }
        .difficulty-btn { animation: diffBtnIn 0.4s ease backwards; }
        .difficulty-btn:nth-child(1) { animation-delay: 0.05s; }
        .difficulty-btn:nth-child(2) { animation-delay: 0.15s; }
        .difficulty-btn:nth-child(3) { animation-delay: 0.25s; }

        @keyframes orbFloat {
            0%,100% { transform: translateY(0); }
            50%      { transform: translateY(-3px); }
        }
        /* Only animate every other orb to save GPU */
        .hp-orb-wrap:nth-child(odd) { animation: orbFloat 2.2s ease-in-out infinite; }
        .hp-orb-wrap:nth-child(even) { animation: orbFloat 2.2s ease-in-out infinite 1.1s; }

        @keyframes leaderFadeIn {
            from { opacity:0; transform: translateX(-15px); }
            to   { opacity:1; transform: translateX(0); }
        }
        .leaderboard-entry { animation: leaderFadeIn 0.3s ease backwards; }

        @keyframes screenFlash {
            0%   { opacity: 0.65; }
            100% { opacity: 0; }
        }
        #damageFlash {
            position: fixed; inset: 0;
            background: #ef4444;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
        }
        #damageFlash.flash { animation: screenFlash 0.25s ease-out forwards; }

        @keyframes npcSpawn {
            0%   { transform: scale(0) rotate(-30deg); opacity: 0; }
            60%  { transform: scale(1.15) rotate(5deg); opacity: 1; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }
        .npc-spawn { animation: npcSpawn 0.5s cubic-bezier(.22,1,.36,1) forwards; }


        /* Difficulty Selector */
        .difficulty-selector {
            background: linear-gradient(135deg, rgba(0, 87, 183, 0.2), rgba(255, 215, 0, 0.2));
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            text-align: center;
        }

        .difficulty-selector h2 {
            color: #ffd700;
            font-size: 24px;
            margin-bottom: 20px;
            letter-spacing: 3px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .difficulty-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.9));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 150px;
            position: relative;
            overflow: hidden;
        }

        .difficulty-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .difficulty-btn:hover::before {
            left: 100%;
        }

        .difficulty-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .difficulty-btn.easy {
            border-color: #4ade80;
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(34, 197, 94, 0.1));
        }

        .difficulty-btn.easy:hover,
        .difficulty-btn.easy.selected {
            border-color: #4ade80;
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.3), rgba(34, 197, 94, 0.3));
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
        }

        .difficulty-btn.normal {
            border-color: #fbbf24;
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.1));
        }

        .difficulty-btn.normal:hover,
        .difficulty-btn.normal.selected {
            border-color: #fbbf24;
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.3), rgba(245, 158, 11, 0.3));
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        }

        .difficulty-btn.hard {
            border-color: #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1));
        }

        .difficulty-btn.hard:hover,
        .difficulty-btn.hard.selected {
            border-color: #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(220, 38, 38, 0.3));
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }

        .diff-name {
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .diff-desc {
            color: #94a3b8;
            font-size: 12px;
        }

        .difficulty-selector.hidden {
            display: none;
        }

        .difficulty-display {
            color: #ffd700;
            font-weight: bold;
            font-size: 16px;
            padding: 5px 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 5px;
            border: 1px solid #ffd700;
        }

        /* Controls reorganized */
        .controls {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .image-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            padding: 15px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        #playBtn {
            font-size: 18px;
            padding: 12px 30px;
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: #10b981;
        }

        #playBtn:hover {
            background: linear-gradient(135deg, #059669, #10b981);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.6);
        }

        /* Mobile controls */
        .mobile-controls {
            display: none;
            position: relative;
            width: 100%;
            height: 180px;
            pointer-events: none;
            z-index: 100;
            margin-top: 8px;
        }

        .mobile-controls.active {
            display: block;
        }

        /* Joysticks always visible (even outside fullscreen) */
        .mobile-controls.always-visible {
            display: block;
        }

        .joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            pointer-events: all;
        }

        .joystick-base {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.3);
            border: 3px solid rgba(102, 126, 234, 0.5);
        }

        .joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        .shoot-joystick-area {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            pointer-events: all;
        }

        .shoot-joystick-base {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(255, 65, 108, 0.3);
            border: 3px solid rgba(255, 65, 108, 0.5);
        }

        .shoot-joystick-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 65, 108, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }

        /* Mobile responsive */
        @media (max-width: 850px) {
            .mobile-controls.active {
                display: block;
            }

            #gameCanvas {
                max-width: 100%;
                height: auto;
            }

            .controls {
                font-size: 12px;
            }

            .control-group label {
                font-size: 12px;
            }

            .file-input-label {
                padding: 6px 12px;
                font-size: 12px;
            }

            button {
                padding: 8px 16px;
                font-size: 14px;
            }

            .stats {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
    padding: 12px;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 10px;
    border: 1px solid rgba(255, 215, 0, 0.3);
}

.stat-value {
    font-size: 20px;
    color: #ffd700;
    font-weight: bold;
}
            .stat-item {
                min-width: 70px;
            }

            .stat-label {
                font-size: 10px;
            }

            .stat-value {
                font-size: 16px;
            }

            h1 {
                font-size: 20px;
            }

            .instructions {
                font-size: 12px;
            }

            .boss-warning {
                font-size: 32px;
                padding: 20px 30px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .game-container {
                padding: 10px;
                border-radius: 10px;
            }

            h1 {
                font-size: 18px;
                margin-bottom: 10px;
            }

            .controls {
                gap: 8px;
            }

            .joystick-area {
                width: 120px;
                height: 120px;
                bottom: 10px;
                left: 10px;
            }

            .joystick-base {
                width: 120px;
                height: 120px;
            }

            .joystick-stick {
                width: 50px;
                height: 50px;
            }

            .shoot-joystick-area {
                width: 120px;
                height: 120px;
                bottom: 10px;
                right: 10px;
            }

            .shoot-joystick-base {
                width: 120px;
                height: 120px;
            }

            .shoot-joystick-stick {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* ‚îÄ‚îÄ PWA Install Banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        #installBanner {
            display: none;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: linear-gradient(135deg, #0057b7, #003b7a);
            border: 1px solid #ffd700;
            border-radius: 12px;
            padding: 12px 18px;
            margin-bottom: 16px;
            color: #fff;
            font-size: 14px;
            animation: diffBtnIn 0.4s ease;
        }
        #installBanner.show { display: flex; }
        #installBanner strong { color: #ffd700; }
        #installBtn {
            white-space: nowrap;
            background: linear-gradient(135deg, #ffd700, #ff8800);
            color: #000;
            border: none;
            font-weight: bold;
            padding: 8px 16px;
            font-size: 13px;
        }
        #installBtn:hover { background: linear-gradient(135deg, #ff8800, #ffd700); }
        #dismissInstall {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            color: #94a3b8;
            padding: 6px 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="game-container">
                <!-- PWA Install Banner -->
        <div id="installBanner">
            <span>üì± <strong>Install as App</strong> ‚Äì play offline, fullscreen, no browser!</span>
            <div style="display:flex;gap:8px">
                <button id="installBtn" onclick="triggerInstall()">‚¨á Install</button>
                <button id="dismissInstall" onclick="document.getElementById('installBanner').classList.remove('show')">‚úï</button>
            </div>
        </div>

        <h1>üéÆ WARZONE SURVIVOR üéÆ</h1>
        
        <!-- Difficulty Selection -->
        <div class="difficulty-selector" id="difficultySelector">
            <h2>SELECT DIFFICULTY</h2>
            <div class="difficulty-buttons">
                <button class="difficulty-btn easy" onclick="selectDifficulty('easy')">
                    <span class="diff-name">EASY</span>
                    <span class="diff-desc">Relaxed gameplay</span>
                </button>
                <button class="difficulty-btn normal selected" onclick="selectDifficulty('normal')">
                    <span class="diff-name">NORMAL</span>
                    <span class="diff-desc">Balanced challenge</span>
                </button>
                <button class="difficulty-btn hard" onclick="selectDifficulty('hard')">
                    <span class="diff-name">HARD</span>
                    <span class="diff-desc">Brutal warfare</span>
                </button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <span class="stat-label">SCORE</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">WAVE</span>
                <span class="stat-value" id="wave">1</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">ENEMIES</span>
                <span class="stat-value" id="enemyCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">KILLS</span>
                <span class="stat-value" id="killCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">BOSSES</span>
                <span class="stat-value" id="bossKillCount">0</span>
            </div>
        </div>

        <div class="health-bar-container" id="healthBarContainer">
            <div class="hp-orbs-row" id="hpOrbsRow">
                <!-- generated by JS -->
            </div>
            <span class="hp-label" id="healthBarText">100 / 100 HP</span>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="controls">
            <button id="playBtn" onclick="startGame()">
                ‚ñ∂ PLAY
            </button>

            <button id="fullscreenBtn" onclick="toggleFullscreen()">
                <span id="fullscreenIcon">‚õ∂</span> FULLSCREEN
            </button>

            <button id="pauseBtn" onclick="togglePause()" disabled>
                ‚è∏ PAUSE
            </button>

            <button id="joystickToggle" onclick="toggleJoysticks()">
                üéÆ TOGGLE JOYSTICKS
            </button>

            <div class="control-group">
                <label>Difficulty:</label>
                <span id="currentDifficulty" class="difficulty-display">NORMAL</span>
            </div>
        </div>

        <div class="image-controls">
            <div class="control-group">
                <label>Player Image:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="playerImage" accept="image/*">
                    <label for="playerImage" class="file-input-label">Choose File</label>
                </div>
            </div>
            
            <div class="control-group">
                <label>Enemy Image:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="enemyImage" accept="image/*">
                    <label for="enemyImage" class="file-input-label">Choose File</label>
                </div>
            </div>

            <div class="control-group">
                <label>Boss Image:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="bossImage" accept="image/*">
                    <label for="bossImage" class="file-input-label">Choose File</label>
                </div>
            </div>

            <div class="control-group">
                <label>Enemy2 Image:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="enemy2Image" accept="image/*">
                    <label for="enemy2Image" class="file-input-label">Choose File</label>
                </div>
            </div>

            <div class="control-group">
                <label>üêæ Strihal Image:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="npcImage" accept="image/*">
                    <label for="npcImage" class="file-input-label">Choose File</label>
                </div>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls" id="mobileControls">
            <div class="joystick-area" id="joystickArea">
                <div class="joystick-base"></div>
                <div class="joystick-stick" id="joystickStick"></div>
            </div>
            <div class="shoot-joystick-area" id="shootJoystickArea">
                <div class="shoot-joystick-base"></div>
                <div class="shoot-joystick-stick" id="shootJoystickStick">üéØ</div>
            </div>
        </div>

        <!-- Floating pause button (visible in fullscreen on mobile) -->
        <button class="floating-pause-btn" id="floatingPauseBtn" onclick="togglePause()">‚è∏</button>

        <!-- Pause Menu Overlay -->
        <div class="pause-overlay" id="pauseOverlay">
            <div class="pause-menu">
                <h2>‚è∏ PAUSED</h2>
                <p>Press P or Esc to resume</p>
                <div class="pause-menu-buttons">
                    <button class="pause-btn-resume" onclick="togglePause()">‚ñ∂ RESUME</button>
                    <button class="pause-btn-restart" onclick="pauseRestart()">üîÑ RESTART</button>
                </div>
            </div>
        </div>

        <div id="damageFlash"></div>
    <div class="boss-warning" id="bossWarning">
            ‚ö† BOSS INCOMING! ‚ö†<br>
            <span style="font-size:28px; font-weight:normal;">I'm going to get you, Holeckek</span>
        </div>

        <div class="game-over" id="gameOver">
            <h2>GAME OVER!</h2>
            <p style="font-size:22px; color:#ffd700; font-style:italic; margin-bottom:10px;">You played well, Radek. ü´°</p>
            <p>Your Score: <span id="finalScore">0</span></p>
            <p>Wave Reached: <span id="finalWave">1</span></p>
            <p>Enemies Killed: <span id="finalKills">0</span></p>
            <p>Bosses Defeated: <span id="finalBosses">0</span></p>
            
            <div class="name-input">
                <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                <button onclick="submitScore()">SUBMIT SCORE</button>
            </div>
            
            <button onclick="restartGame()">Play Again</button>
        </div>

        <div class="leaderboard" id="leaderboard">
            <h3>üèÜ LEADERBOARD üèÜ</h3>
            <div class="leaderboard-content" id="leaderboardContent">
                <p class="leaderboard-empty">No scores yet. Be the first!</p>
            </div>
        </div>

        <div class="instructions">
            <h3>CONTROLS & INFO</h3>
            <ul>
                <li><strong>Start:</strong> Click PLAY button or click anywhere on the game area</li>
                <li><strong>Movement (PC):</strong> WASD or Arrow Keys</li>
                <li><strong>Movement (Mobile):</strong> Left Joystick (blue, bottom-left)</li>
                <li><strong>Shoot (PC):</strong> Mouse - aim and hold to shoot</li>
                <li><strong>Shoot (Mobile):</strong> Right Joystick (red, bottom-right) - drag to aim</li>
                <li><strong>Difficulty:</strong> Select Easy, Normal, or Hard (default: Normal)</li>
                <li><strong>Fullscreen:</strong> Click FULLSCREEN button for immersive gameplay</li>
                <li><strong>Green Orbs:</strong> Collect to restore 20 HP</li>
                <li><strong>Powerups (dropped by enemies):</strong> üõ°Ô∏è Shield ‚Äì blocks damage for 5s | ‚ö° Rapid Fire ‚Äì 3√ó faster shooting for 7s | üíä Mega Heal ‚Äì +50 HP. Boss always drops a powerup!</li>
                <li><strong>Boss System:</strong> Every 20 kills spawns a powerful boss</li>
                <li><strong>Enemy2 (orange):</strong> Unlocks after first boss kill ‚Äì slower but shoots weak projectiles, spawns continuously</li>
                <li><strong>Custom Images:</strong> Upload your own player/enemy/boss images</li>
                <li><strong>üêæ Strihal:</strong> NPC companion ‚Äì 25% chance to spawn after killing a boss. Collects health orbs, shoots at enemies. Upload npc.jpg for a custom photo!</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        // Powerup state
        let shieldActive = false;
        let shieldTimer = 0;
        let rapidFireActive = false;
        let rapidFireTimer = 0;
        let powerups = [];
        let selectedDifficulty = 'normal';  // Default to normal
        let difficultySettings = {
            easy: {
                playerDamage: 25,
                playerDamagePerWave: 5,
                enemyHealth: 17,
                enemyHealthPerWave: 5,
                enemySpeed: 0.8,
                enemySpeedPerWave: 0.05,
                bossHealth: 160,
                bossHealthPerWave: 30,
                bossShootCooldown: 3000,
                bossDamage: 20,
                enemyCollisionDamage: 3,
                bossCollisionDamage: 8
            },
            normal: {
                playerDamage: 13,
                playerDamagePerWave: 3,
                enemyHealth: 22,
                enemyHealthPerWave: 10,
                enemySpeed: 1,
                enemySpeedPerWave: 0.1,
                bossHealth: 200,
                bossHealthPerWave: 50,
                bossShootCooldown: 2000,
                bossDamage: 30,
                enemyCollisionDamage: 5,
                bossCollisionDamage: 10
            },
            hard: {
                playerDamage: 10,
                playerDamagePerWave: 2,
                enemyHealth: 33,
                enemyHealthPerWave: 15,
                enemySpeed: 1.5,
                enemySpeedPerWave: 0.15,
                bossHealth: 300,
                bossHealthPerWave: 75,
                bossShootCooldown: 1500,
                bossDamage: 30,
                enemyCollisionDamage: 8,
                bossCollisionDamage: 15
            }
        };
        
        let player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 25,
            color: '#00ff00',
            image: null,
            speed: 4
        };

        let enemies = [];
        let projectiles = [];
        let bossProjectiles = [];  // Boss projectiles
        let healthOrbs = [];
        let powerupItems = [];

        // ‚îÄ‚îÄ NPC companion ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let npc = null;   // null = not active
        let npcProjectiles = [];
        const NPC_LEASH = 80;   // ideal follow distance
        const NPC_SHOOT_CD = 90; // frames between shots
        let score = 0;
        let wave = 1;
        let health = 100;
        let maxHealth = 100;
        let killCount = 0;
        let bossKillCount = 0;
        let bossKillsTotal = 0;   // total bosses killed (unlocks enemy2)
        let killsUntilBoss = 20;
        let bossActive = false;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let keys = {};
        let mouseDown = false;
        let lastShootTime = 0;
        let shootCooldown = 150;

        // Mobile controls with individual touch tracking
        let moveJoystickTouchId = null;
        let shootJoystickTouchId = null;
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        let mobileMovementX = 0;
        let mobileMovementY = 0;
        let shootJoystickActive = false;
        let shootJoystickAngle = 0;
        let shootJoystickDistance = 0;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Leaderboard
        let leaderboard = [];

        // Load leaderboard from localStorage
        function loadLeaderboard() {
            const saved = localStorage.getItem('warzoneLeaderboard');
            if (saved) {
                leaderboard = JSON.parse(saved);
            }
            updateLeaderboardDisplay();
        }

        // Save leaderboard to localStorage
        function saveLeaderboard() {
            localStorage.setItem('warzoneLeaderboard', JSON.stringify(leaderboard));
        }

        // Submit score to leaderboard
        function submitScore() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim() || 'Anonymous';
            
            const entry = {
                name: name,
                score: score,
                wave: wave,
                kills: killCount,
                bosses: bossKillCount,
                difficulty: selectedDifficulty,
                date: new Date().toISOString()
            };
            
            leaderboard.push(entry);
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, 10); // Keep top 10
            
            saveLeaderboard();
            updateLeaderboardDisplay();
            
            nameInput.value = '';
            nameInput.disabled = true;
            document.querySelector('.name-input button').disabled = true;
        }

        // Update leaderboard display
        function updateLeaderboardDisplay() {
            const content = document.getElementById('leaderboardContent');
            
            if (leaderboard.length === 0) {
                content.innerHTML = '<p class="leaderboard-empty">No scores yet. Be the first!</p>';
                return;
            }
            
            let html = '';
            leaderboard.forEach((entry, index) => {
                const rankClass = index === 0 ? 'top1' : index === 1 ? 'top2' : index === 2 ? 'top3' : '';
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`;
                const diffColor = entry.difficulty === 'easy' ? '#4ade80' : entry.difficulty === 'normal' ? '#fbbf24' : '#ef4444';
                
                html += `
                    <div class="leaderboard-entry ${rankClass}">
                        <span class="leaderboard-rank">${medal}</span>
                        <span class="leaderboard-name">${entry.name}</span>
                        <span class="leaderboard-stats">W${entry.wave} | K${entry.kills} | <span style="color: ${diffColor}">${entry.difficulty.toUpperCase()}</span></span>
                        <span class="leaderboard-score">${entry.score.toLocaleString()}</span>
                    </div>
                `;
            });
            
            content.innerHTML = html;
        }

        // Toggle joysticks visibility (funguje pro v≈°echny, i PC)
        function toggleJoysticks() {
            const controls = document.getElementById('mobileControls');
            const isVisible = controls.classList.contains('active') || controls.classList.contains('always-visible');
            if (isVisible) {
                controls.classList.remove('active');
                controls.classList.remove('always-visible');
                document.getElementById('joystickToggle').textContent = 'üéÆ SHOW JOYSTICKS';
            } else {
                controls.classList.add('always-visible');
                document.getElementById('joystickToggle').textContent = 'üéÆ HIDE JOYSTICKS';
            }
        }

        // Images
        let playerImg = null;
        let enemyImg = null;
        let enemy2Img = null;
        let bossImg = null;
        let boss2Img = null;
        let npcImg = null;
        let bossToggle = 0; // alternates 0/1 for each boss spawn

        // Auto-load images from folder
        function loadImagesFromFolder() {
            const playerImage = new Image();
            playerImage.onload = function() {
                playerImg = playerImage;
                player.image = playerImage;
                console.log('Player image loaded: player.jpg');
            };
            playerImage.onerror = function() {
                console.log('Player image not found (player.jpg) - using default circle');
            };
            playerImage.src = 'player.jpg';

            const enemyImage = new Image();
            enemyImage.onload = function() {
                enemyImg = enemyImage;
                console.log('Enemy image loaded: enemy.jpg');
            };
            enemyImage.onerror = function() {
                console.log('Enemy image not found (enemy.jpg) - using default circle');
            };
            enemyImage.src = 'enemy.jpg';

            const enemy2Image = new Image();
            enemy2Image.onload = function() {
                enemy2Img = enemy2Image;
                console.log('Enemy2 image loaded: enemy2.jpg');
            };
            enemy2Image.onerror = function() {
                console.log('Enemy2 image not found (enemy2.jpg) - using default');
            };
            enemy2Image.src = 'enemy2.jpg';

            const bossImage = new Image();
            bossImage.onload = function() {
                bossImg = bossImage;
                console.log('Boss image loaded: boss.jpg');
            };
            bossImage.onerror = function() {
                console.log('Boss image not found (boss.jpg) - using default circle');
            };
            bossImage.src = 'boss.jpg';

            const boss2Image = new Image();
            boss2Image.onload = function() {
                boss2Img = boss2Image;
                console.log('Boss2 image loaded: boss2.jpg');
            };
            boss2Image.onerror = function() {
                console.log('Boss2 image not found (boss2.jpg) - using boss1 as fallback');
            };
            boss2Image.src = 'boss2.jpg';

            const npcImage = new Image();
            npcImage.onload = function() { npcImg = npcImage; };
            npcImage.src = 'npc.jpg';
        }

        loadImagesFromFolder();
        loadLeaderboard();

        document.getElementById('npcImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                const img = new Image();
                img.onload = function() { npcImg = img; };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Difficulty selection
        function selectDifficulty(difficulty) {
            selectedDifficulty = difficulty;
            
            // Remove selected class from all buttons
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Add selected class to clicked button
            event.target.closest('.difficulty-btn').classList.add('selected');
            
            document.getElementById('difficultySelector').classList.add('hidden');
            document.getElementById('currentDifficulty').textContent = difficulty.toUpperCase();
            document.getElementById('currentDifficulty').style.color = 
                difficulty === 'easy' ? '#4ade80' : 
                difficulty === 'normal' ? '#fbbf24' : '#ef4444';
        }

        // Canvas dimensions management
        const CANVAS_ORIG_W = 800;
        const CANVAS_ORIG_H = 600;

        function resizeCanvasForFullscreen() {
            const container = document.querySelector('.game-container');
            const isPortrait = window.innerHeight > window.innerWidth;
            const isFs = container.classList.contains('fullscreen');

            if (!isFs) {
                // Normal mode - restore original internal size
                canvas.width = CANVAS_ORIG_W;
                canvas.height = CANVAS_ORIG_H;
                canvas.style.width = '';
                canvas.style.height = '';
                return;
            }

            // Fullscreen mode
            const statsH = document.querySelector('.stats').offsetHeight || 0;
            const hpH = document.querySelector('.health-bar-container').offsetHeight || 0;
            const uiH = statsH + hpH;

            const availW = window.innerWidth;
            const availH = window.innerHeight - uiH;

            let newW, newH;

            if (isPortrait) {
                // Portrait: fill full width, keep aspect ratio (can be taller than original)
                newW = availW;
                newH = availH;
            } else {
                // Landscape: fit by height, keep 4:3 ratio
                const ratio = CANVAS_ORIG_W / CANVAS_ORIG_H;
                newH = availH;
                newW = Math.min(availW, Math.round(newH * ratio));
                if (newW > availW) {
                    newW = availW;
                    newH = Math.round(newW / ratio);
                }
            }

            // Set internal canvas resolution to match display size
            canvas.width = newW;
            canvas.height = newH;
            canvas.style.width = newW + 'px';
            canvas.style.height = newH + 'px';
            canvas.style.marginLeft = 'auto';
            canvas.style.marginRight = 'auto';
            canvas.style.display = 'block';

            // Reposition player proportionally
            if (gameRunning) {
                player.x = Math.min(Math.max(player.x, player.radius), newW - player.radius);
                player.y = Math.min(Math.max(player.y, player.radius), newH - player.radius);
            } else {
                player.x = newW / 2;
                player.y = newH / 2;
            }
        }

        // Fullscreen toggle
        function toggleFullscreen() {
            const container = document.querySelector('.game-container');
            const floatBtn = document.getElementById('floatingPauseBtn');
            
            if (!document.fullscreenElement) {
                container.classList.add('fullscreen');
                document.getElementById('fullscreenIcon').textContent = '‚õ∂';
                floatBtn.classList.add('visible');

                const req = container.requestFullscreen || container.webkitRequestFullscreen || container.msRequestFullscreen;
                if (req) req.call(container).catch(() => {});

                setTimeout(resizeCanvasForFullscreen, 100);
            } else {
                container.classList.remove('fullscreen');
                document.getElementById('fullscreenIcon').textContent = '‚õ∂';
                floatBtn.classList.remove('visible');

                const exit = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
                if (exit) exit.call(document).catch(() => {});

                resizeCanvasForFullscreen();
            }
        }

        // Listen for fullscreen changes (e.g. user presses Escape)
        document.addEventListener('fullscreenchange', () => {
            const container = document.querySelector('.game-container');
            const floatBtn = document.getElementById('floatingPauseBtn');
            if (!document.fullscreenElement) {
                container.classList.remove('fullscreen');
                floatBtn.classList.remove('visible');
                resizeCanvasForFullscreen();
            }
        });
        document.addEventListener('webkitfullscreenchange', () => {
            const container = document.querySelector('.game-container');
            const floatBtn = document.getElementById('floatingPauseBtn');
            if (!document.webkitFullscreenElement) {
                container.classList.remove('fullscreen');
                floatBtn.classList.remove('visible');
                resizeCanvasForFullscreen();
            }
        });

        // Re-resize when device is rotated in fullscreen
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvasForFullscreen, 200);
        });
        window.addEventListener('resize', () => {
            const container = document.querySelector('.game-container');
            if (container.classList.contains('fullscreen')) {
                resizeCanvasForFullscreen();
            }
        });

        // Image upload handlers
        document.getElementById('playerImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        playerImg = img;
                        player.image = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('enemyImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        enemyImg = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('enemy2Image').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        enemy2Img = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('bossImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        bossImg = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Mouse events
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            shoot();
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('click', () => {
            if (!gameRunning) {
                startGame();
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                if (gameRunning) togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mobile touch controls - IMPROVED VERSION
        const joystickArea = document.getElementById('joystickArea');
        const joystickStick = document.getElementById('joystickStick');
        const shootJoystickArea = document.getElementById('shootJoystickArea');
        const shootJoystickStick = document.getElementById('shootJoystickStick');

        // Movement joystick controls - tracks specific touch
        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Only start if not already tracking a touch
            if (moveJoystickTouchId === null && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                moveJoystickTouchId = touch.identifier;
                joystickActive = true;
                const rect = joystickArea.getBoundingClientRect();
                joystickStartX = rect.left + rect.width / 2;
                joystickStartY = rect.top + rect.height / 2;
                updateJoystick(touch.clientX, touch.clientY);
            }
        });

        joystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystickActive || moveJoystickTouchId === null) return;
            
            // Find the touch with our tracked ID
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === moveJoystickTouchId) {
                    updateJoystick(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        });

        joystickArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            // Check if our tracked touch ended
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === moveJoystickTouchId) {
                    moveJoystickTouchId = null;
                    joystickActive = false;
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                    mobileMovementX = 0;
                    mobileMovementY = 0;
                    break;
                }
            }
        });

        joystickArea.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === moveJoystickTouchId) {
                    moveJoystickTouchId = null;
                    joystickActive = false;
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                    mobileMovementX = 0;
                    mobileMovementY = 0;
                    break;
                }
            }
        });

        function updateJoystick(touchX, touchY) {
            const maxDistance = 45;
            let deltaX = touchX - joystickStartX;
            let deltaY = touchY - joystickStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }

            joystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

            mobileMovementX = deltaX / maxDistance;
            mobileMovementY = deltaY / maxDistance;
        }

        // Shooting joystick controls - tracks specific touch
        shootJoystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Only start if not already tracking a touch
            if (shootJoystickTouchId === null && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                shootJoystickTouchId = touch.identifier;
                shootJoystickActive = true;
                const rect = shootJoystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                updateShootJoystick(touch.clientX, touch.clientY, centerX, centerY);
            }
        });

        shootJoystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!shootJoystickActive || shootJoystickTouchId === null) return;
            
            // Find the touch with our tracked ID
            const rect = shootJoystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === shootJoystickTouchId) {
                    updateShootJoystick(e.touches[i].clientX, e.touches[i].clientY, centerX, centerY);
                    break;
                }
            }
        });

        shootJoystickArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            // Check if our tracked touch ended
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === shootJoystickTouchId) {
                    shootJoystickTouchId = null;
                    shootJoystickActive = false;
                    shootJoystickStick.style.transform = 'translate(-50%, -50%)';
                    shootJoystickDistance = 0;
                    break;
                }
            }
        });

        shootJoystickArea.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === shootJoystickTouchId) {
                    shootJoystickTouchId = null;
                    shootJoystickActive = false;
                    shootJoystickStick.style.transform = 'translate(-50%, -50%)';
                    shootJoystickDistance = 0;
                    break;
                }
            }
        });

        function updateShootJoystick(touchX, touchY, centerX, centerY) {
            const maxDistance = 45;
            let deltaX = touchX - centerX;
            let deltaY = touchY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }

            shootJoystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

            shootJoystickAngle = Math.atan2(deltaY, deltaX);
            shootJoystickDistance = Math.min(distance / maxDistance, 1);
        }

        function shoot() {
            const now = Date.now();
            if (now - lastShootTime < (rapidFireActive ? shootCooldown * 0.3 : shootCooldown)) return;
            lastShootTime = now;

            let angle;
            if (isMobile && shootJoystickActive && shootJoystickDistance > 0.1) {
                // Mobile: shoot in joystick direction
                angle = shootJoystickAngle;
            } else {
                // Desktop: shoot towards mouse
                const dx = mouseX - player.x;
                const dy = mouseY - player.y;
                angle = Math.atan2(dy, dx);
            }

            const speed = 8;
            const settings = difficultySettings[selectedDifficulty];
            projectiles.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: 5,
                color: '#ffff00',
                damage: settings.playerDamage + (wave - 1) * settings.playerDamagePerWave
            });
        }

        function createEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -20; break;
                case 1: x = canvas.width + 20; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 20; break;
                case 3: x = -20; y = Math.random() * canvas.height; break;
            }

            const settings = difficultySettings[selectedDifficulty];
            const enemyHealth = settings.enemyHealth + wave * settings.enemyHealthPerWave;
            
            enemies.push({
                x: x,
                y: y,
                radius: 20,
                color: '#ff0000',
                speed: settings.enemySpeed + wave * settings.enemySpeedPerWave,
                health: enemyHealth,
                maxHealth: enemyHealth,
                isBoss: false
            });
        }

        function createEnemy2() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -20; break;
                case 1: x = canvas.width + 20; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 20; break;
                case 3: x = -20; y = Math.random() * canvas.height; break;
            }
            const settings = difficultySettings[selectedDifficulty];
            const hp = Math.round((settings.enemyHealth + wave * settings.enemyHealthPerWave) * 0.65);
            enemies.push({
                x: x, y: y,
                radius: 18,
                color: '#ff6600',
                speed: (settings.enemySpeed + wave * settings.enemySpeedPerWave) * 0.75,
                health: hp, maxHealth: hp,
                isBoss: false,
                isEnemy2: true,
                lastShootTime: Date.now(),
                shootCooldown: 2500   // shoots every 2.5s
            });
        }

        function createBoss() {
            bossActive = true;
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -50; break;
                case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                case 3: x = -50; y = Math.random() * canvas.height; break;
            }

            const settings = difficultySettings[selectedDifficulty];
            const currentBossType = bossToggle++ % 2;
            const isTrump = currentBossType === 1;
            const bossHealth = (settings.bossHealth + wave * settings.bossHealthPerWave) * (isTrump ? 1.5 : 1);
            enemies.push({
                x: x,
                y: y,
                radius: isTrump ? 58 : 50,
                color: isTrump ? '#ff8c00' : '#ff00ff',
                speed: (isTrump ? 1.2 : 0.8) + wave * 0.05,
                health: Math.round(bossHealth),
                maxHealth: Math.round(bossHealth),
                isBoss: true,
                bossType: currentBossType,
                lastShootTime: Date.now(),
                shootCooldown: isTrump ? settings.bossShootCooldown * 0.7 : settings.bossShootCooldown
            });

            const warning = document.getElementById('bossWarning');
            warning.classList.add('show');
            setTimeout(() => {
                warning.classList.remove('show');
            }, 1500);
        }


        // ‚îÄ‚îÄ Particle & floating text system ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let particles = [];
        let floatingTexts = [];

        const MAX_PARTICLES = 120;
        function spawnParticles(x, y, count, color, isBoss) {
            // Cap total particles to avoid lag
            const available = MAX_PARTICLES - particles.length;
            const actual = Math.min(count, available, isBoss ? 40 : 18);
            for (let i = 0; i < actual; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = isBoss ? (2 + Math.random() * 5) : (1 + Math.random() * 3);
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: isBoss ? (2 + Math.random() * 4) : (1.5 + Math.random() * 2.5),
                    color: color,
                    life: 1.0,
                    decay: isBoss ? (0.018 + Math.random() * 0.012) : (0.028 + Math.random() * 0.02)
                });
            }
        }

        function spawnFloatingText(x, y, text, color) {
            if (floatingTexts.length > 20) return; // cap
            floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.8 });
        }

        function triggerDamageFlash() {
            const el = document.getElementById('damageFlash');
            el.classList.remove('flash');
            void el.offsetWidth; // reflow
            el.classList.add('flash');
        }

        function popStat(id) {
            const el = document.getElementById(id);
            if (!el) return;
            el.classList.remove('popped');
            void el.offsetWidth;
            el.classList.add('popped');
            el.addEventListener('animationend', () => el.classList.remove('popped'), { once: true });
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                p.vy += 0.08; // gravity
                p.vx *= 0.97;
                p.life -= p.decay;
                return p.life > 0;
            });
        }

        function drawParticles() {
            // Batch same-color particles, no shadow for perf
            ctx.save();
            particles.forEach(p => {
                ctx.globalAlpha = p.life * 0.9;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * p.life, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function updateFloatingTexts() {
            floatingTexts = floatingTexts.filter(t => {
                t.y += t.vy;
                t.life -= 0.022;
                return t.life > 0;
            });
        }

        function drawFloatingTexts() {
            ctx.save();
            ctx.font = 'bold 15px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            floatingTexts.forEach(t => {
                ctx.globalAlpha = t.life;
                ctx.fillStyle = t.color;
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function spawnNpc() {
            npc = {
                x: player.x + 60,
                y: player.y + 40,
                radius: 20,
                shootTimer: NPC_SHOOT_CD,
                angle: 0
            };
            showPowerupMsg('üêæ Strihal joined!');
        }

        function createHealthOrb(x, y) {
            healthOrbs.push({
                x: x,
                y: y,
                radius: 15,
                healAmount: 20,
                lifetime: 300
            });
        }

        function drawPlayer() {
            // Shield effect
            if (shieldActive) {
                const pulse = Math.sin(Date.now() / 150) * 4;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 12 + pulse, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 200, 255, 0.9)`;
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 8 + pulse, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 200, 255, 0.15)`;
                ctx.fill();
            }
            // Rapid fire indicator
            if (rapidFireActive) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 200, 0, 0.7)`;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            if (player.image) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.clip();
                ctx.drawImage(player.image, 
                    player.x - player.radius, 
                    player.y - player.radius, 
                    player.radius * 2, 
                    player.radius * 2);
                ctx.restore();
            } else {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function drawEnemy(enemy) {
            if (enemy.isBoss) {
                const imgToDraw = (enemy.bossType === 1 && boss2Img) ? boss2Img : (bossImg || null);
                if (imgToDraw) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(imgToDraw, 
                        enemy.x - enemy.radius, 
                        enemy.y - enemy.radius, 
                        enemy.radius * 2, 
                        enemy.radius * 2);
                    ctx.restore();
                } else {
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    ctx.fillStyle = enemy.color;
                    ctx.fill();
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
            } else if (enemy.isEnemy2 && enemy2Img) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.clip();
                ctx.drawImage(enemy2Img,
                    enemy.x - enemy.radius,
                    enemy.y - enemy.radius,
                    enemy.radius * 2,
                    enemy.radius * 2);
                ctx.restore();
            } else if (!enemy.isBoss && !enemy.isEnemy2 && enemyImg) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.clip();
                ctx.drawImage(enemyImg, 
                    enemy.x - enemy.radius, 
                    enemy.y - enemy.radius, 
                    enemy.radius * 2, 
                    enemy.radius * 2);
                ctx.restore();
            } else {
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                ctx.strokeStyle = enemy.isBoss ? '#ff00ff' : (enemy.isEnemy2 ? '#ff6600' : '#fff');
                ctx.lineWidth = enemy.isBoss ? 4 : 2;
                ctx.stroke();
            }

            // Health bar
            const barWidth = enemy.radius * 2;
            const barHeight = 5;
            const barX = enemy.x - enemy.radius;
            const barY = enemy.y - enemy.radius - 10;
            
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.fillStyle = enemy.isBoss ? '#ff00ff' : (enemy.isEnemy2 ? '#ff6600' : '#ff0000');
            ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

            // Boss charging effect p≈ôed vyst≈ôelen√≠m
            if (enemy.isBoss && enemy.lastShootTime) {
                const timeSinceLastShot = Date.now() - enemy.lastShootTime;
                const chargePercent = timeSinceLastShot / enemy.shootCooldown;
                
                if (chargePercent > 0.85) {  // Only glow in last 15% before shot (perf)
                    const glowIntensity = (chargePercent - 0.7) / 0.3;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius + 10, 0, Math.PI * 2);
                    ctx.fillStyle = enemy.bossType === 1
                        ? `rgba(255, 140, 0, ${glowIntensity * 0.4})`
                        : `rgba(255, 0, 255, ${glowIntensity * 0.3})`;
                    ctx.fill();
                }
            }

            // Boss name label
            if (enemy.isBoss) {
                ctx.save();
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillStyle = enemy.bossType === 1 ? '#ffaa00' : '#ff66ff';
                ctx.fillText(enemy.bossType === 1 ? 'trump' : 'putin', enemy.x, enemy.y + enemy.radius + 6);
                ctx.restore();
            }
        }

        function drawProjectile(projectile) {
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffff00';
            ctx.fill();
            ctx.strokeStyle = '#ff8800';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawHealthOrb(orb) {
            const t = Date.now();
            const pulse = Math.sin(t / 140) * 2;
            const r = orb.radius + pulse;
            const cx = orb.x, cy = orb.y;

            ctx.save();

            // Outer glow
            const glow = ctx.createRadialGradient(cx, cy, r * 0.3, cx, cy, r + 7);
            glow.addColorStop(0, 'rgba(0,100,255,0.0)');
            glow.addColorStop(1, 'rgba(0,80,220,0.35)');
            ctx.beginPath();
            ctx.arc(cx, cy, r + 7, 0, Math.PI * 2);
            ctx.fillStyle = glow;
            ctx.fill();

            // Clip to circle for Pepsi halves
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.clip();

            // Red top half
            ctx.fillStyle = '#e8162a';
            ctx.fillRect(cx - r, cy - r, r * 2, r);
            // Blue bottom half
            ctx.fillStyle = '#004b93';
            ctx.fillRect(cx - r, cy, r * 2, r);

            // White wavy stripe in middle (Pepsi wave)
            ctx.beginPath();
            ctx.moveTo(cx - r, cy - r * 0.18);
            ctx.bezierCurveTo(cx - r * 0.5, cy - r * 0.18, cx - r * 0.3, cy + r * 0.28, cx, cy + r * 0.12);
            ctx.bezierCurveTo(cx + r * 0.3, cy - r * 0.08, cx + r * 0.5, cy + r * 0.28, cx + r, cy + r * 0.18);
            ctx.lineTo(cx + r, cy - r * 0.18);
            ctx.bezierCurveTo(cx + r * 0.5, cy - r * 0.18, cx + r * 0.3, cy - r * 0.44, cx, cy - r * 0.12);
            ctx.bezierCurveTo(cx - r * 0.3, cy + r * 0.14, cx - r * 0.5, cy - r * 0.18, cx - r, cy - r * 0.18);
            ctx.closePath();
            ctx.fillStyle = '#ffffff';
            ctx.fill();

            ctx.restore();

            // Border ring
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2.5;
            ctx.stroke();

            // "+20" label below
            ctx.save();
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#fff';
            ctx.fillText('+20 HP', cx, cy + r + 4);
            ctx.restore();
        }

        function drawBossProjectile(projectile) {
            if (projectile.isEnemy2Shot) {
                // Orange small enemy2 projectile
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius + 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6600';
                ctx.fill();
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                return;
            }
            // Vnƒõj≈°√≠ z√°≈ôe
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius + 5, 0, Math.PI * 2);
            ctx.fillStyle = projectile.isTrumpShot ? 'rgba(255, 140, 0, 0.35)' : 'rgba(255, 0, 255, 0.3)';
            ctx.fill();

            // Hlavn√≠ projektil
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
            ctx.fillStyle = projectile.isTrumpShot ? '#ff8c00' : '#ff00ff';
            ctx.fill();
            ctx.strokeStyle = projectile.isTrumpShot ? '#ffd700' : '#ff66ff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updatePlayer() {
            let dx = 0;
            let dy = 0;

            // Keyboard controls
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;

            // Mobile joystick controls
            if (joystickActive) {
                dx = mobileMovementX;
                dy = mobileMovementY;
            }

            // Normalize diagonal movement (only for keyboard)
            if ((keys['w'] || keys['s'] || keys['a'] || keys['d'] || 
                 keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright']) &&
                dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            player.x += dx * player.speed;
            player.y += dy * player.speed;

            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            // Auto-shoot when shooting joystick is active
            if (shootJoystickActive && shootJoystickDistance > 0.1) {
                shoot();
            }

            // Desktop auto-shoot
            if (mouseDown) {
                shoot();
            }
        }

        function updateProjectiles() {
            projectiles = projectiles.filter(projectile => {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;

                if (projectile.x < 0 || projectile.x > canvas.width ||
                    projectile.y < 0 || projectile.y > canvas.height) {
                    return false;
                }

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < projectile.radius + enemy.radius) {
                        enemy.health -= projectile.damage;
                        
                        if (enemy.health <= 0) {
                            createHealthOrb(enemy.x, enemy.y);
                            // Powerup drop chance
                            const dropRoll = Math.random();
                            if (enemy.isBoss) {
                                // Boss always drops a powerup
                                spawnPowerup(enemy.x, enemy.y);
                            } else if (dropRoll < 0.07) {
                                // Regular enemies 7% chance
                                spawnPowerup(enemy.x, enemy.y);
                            }
                            enemies.splice(i, 1);
                            
                            if (enemy.isBoss) {
                                score += 1000;
                                bossKillCount++;
                                bossKillsTotal++;
                                bossActive = false;
                                killsUntilBoss = 20;
                                // 25% chance to unlock Strihal
                                if (!npc && Math.random() < 0.25) { spawnNpc(); }
                                spawnParticles(enemy.x, enemy.y, 60, enemy.bossType === 1 ? '#ff8c00' : '#ff00ff', true);
                                spawnFloatingText(enemy.x, enemy.y - 60, enemy.bossType === 1 ? 'üíÄ TRUMP DOWN! +1000' : 'üíÄ PUTIN DOWN! +1000', '#ffd700');
                                popStat('bossKillCount');
                            } else if (enemy.isEnemy2) {
                                score += 50;
                                killCount++;
                                killsUntilBoss--;
                                spawnParticles(enemy.x, enemy.y, 14, '#ff6600', false);
                                spawnFloatingText(enemy.x, enemy.y - 30, '+50', '#ff9955');
                                popStat('killCount');
                            } else {
                                score += 100;
                                killCount++;
                                killsUntilBoss--;
                                spawnParticles(enemy.x, enemy.y, 18, '#ff4444', false);
                                spawnFloatingText(enemy.x, enemy.y - 30, '+100', '#ff8888');
                                popStat('killCount');
                            }
                        }
                        
                        return false;
                    }
                }

                return true;
            });
        }

        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                enemy.x += (dx / distance) * enemy.speed;
                enemy.y += (dy / distance) * enemy.speed;

                // Boss shoots projectiles
                if (enemy.isBoss) {
                    const now = Date.now();
                    if (now - enemy.lastShootTime > enemy.shootCooldown) {
                        enemy.lastShootTime = now;
                        const settings = difficultySettings[selectedDifficulty];

                        if (enemy.bossType === 1) {
                            // TRUMP: kruhov√Ω salvo ‚Äì 8 projektil≈Ø do v≈°ech smƒõr≈Ø + 3 zamƒõ≈ôen√©
                            const baseAngle = Math.atan2(dy, dx);
                            for (let i = 0; i < 8; i++) {
                                const angle = (Math.PI * 2 / 8) * i;
                                bossProjectiles.push({
                                    x: enemy.x, y: enemy.y,
                                    vx: Math.cos(angle) * 3.5,
                                    vy: Math.sin(angle) * 3.5,
                                    radius: 10,
                                    damage: Math.round(settings.bossDamage * 1.3),
                                    isTrumpShot: true
                                });
                            }
                            // + 3 fast targeted shots at player
                            for (let i = -1; i <= 1; i++) {
                                const angle = baseAngle + i * 0.15;
                                bossProjectiles.push({
                                    x: enemy.x, y: enemy.y,
                                    vx: Math.cos(angle) * 6,
                                    vy: Math.sin(angle) * 6,
                                    radius: 7,
                                    damage: Math.round(settings.bossDamage * 0.9),
                                    isTrumpShot: true
                                });
                            }
                        } else {
                            // PUTIN: p≈Øvodn√≠ 3 projektily v rozptylu
                            for (let i = -1; i <= 1; i++) {
                                const angle = Math.atan2(dy, dx) + (i * 0.2);
                                bossProjectiles.push({
                                    x: enemy.x, y: enemy.y,
                                    vx: Math.cos(angle) * 4,
                                    vy: Math.sin(angle) * 4,
                                    radius: 8,
                                    damage: settings.bossDamage
                                });
                            }
                        }
                    }
                }

                // Enemy2 shoots one weak projectile
                if (enemy.isEnemy2) {
                    const now = Date.now();
                    if (now - enemy.lastShootTime > enemy.shootCooldown) {
                        enemy.lastShootTime = now;
                        const angle = Math.atan2(dy, dx);
                        bossProjectiles.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: Math.cos(angle) * 2.5,
                            vy: Math.sin(angle) * 2.5,
                            radius: 5,
                            damage: 3,          // weak damage
                            isEnemy2Shot: true
                        });
                    }
                }

                const collisionDistance = player.radius + enemy.radius;
                if (distance < collisionDistance) {
                    const settings = difficultySettings[selectedDifficulty];
                    let dmg;
                    if (enemy.isBoss) dmg = settings.bossCollisionDamage;
                    else if (enemy.isEnemy2) dmg = Math.round(settings.enemyCollisionDamage * 0.6);
                    else dmg = settings.enemyCollisionDamage;
                    if (!shieldActive) {
                        health -= dmg;
                        triggerDamageFlash();
                        spawnFloatingText(player.x, player.y - 40, '-' + dmg + ' HP', '#ef4444');
                    } else {
                        spawnFloatingText(player.x, player.y - 40, 'üõ° BLOCKED!', '#00c8ff');
                    }
                    enemies.splice(index, 1);
                    if (enemy.isBoss) {
                        bossActive = false;
                    }
                    updateHealthBar();

                    if (health <= 0) {
                        gameOver();
                    }
                }
            });
        }

        function updateNpc() {
            if (!npc) return;

            // Follow player with spring leash
            const dx = player.x - npc.x;
            const dy = player.y - npc.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const targetDist = NPC_LEASH;
            if (dist > targetDist + 5) {
                const speed = Math.min((dist - targetDist) * 0.12, 5);
                npc.x += (dx / dist) * speed;
                npc.y += (dy / dist) * speed;
            }

            // Collect nearby health orbs
            healthOrbs = healthOrbs.filter(orb => {
                const ox = orb.x - npc.x, oy = orb.y - npc.y;
                if (Math.sqrt(ox*ox + oy*oy) < npc.radius + orb.radius + 30) {
                    health = Math.min(maxHealth, health + orb.healAmount);
                    updateHealthBar();
                    showPowerupMsg('üêæ Strihal picked up +' + orb.healAmount + ' HP!');
                    return false;
                }
                return true;
            });

            // Shoot at nearest enemy
            npc.shootTimer--;
            if (npc.shootTimer <= 0) {
                npc.shootTimer = NPC_SHOOT_CD;
                let nearest = null, nearestDist = 999999;
                enemies.forEach(e => {
                    const ex = e.x - npc.x, ey = e.y - npc.y;
                    const d = Math.sqrt(ex*ex + ey*ey);
                    if (d < nearestDist) { nearestDist = d; nearest = e; }
                });
                if (nearest) {
                    const a = Math.atan2(nearest.y - npc.y, nearest.x - npc.x);
                    npcProjectiles.push({
                        x: npc.x, y: npc.y,
                        vx: Math.cos(a) * 7, vy: Math.sin(a) * 7,
                        radius: 5, damage: 15
                    });
                    npc.angle = Math.atan2(nearest.y - npc.y, nearest.x - npc.x);
                } else {
                    npc.angle = Math.atan2(player.y - npc.y, player.x - npc.x);
                }
            }

            // Update NPC projectiles & hit enemies
            npcProjectiles = npcProjectiles.filter(p => {
                p.x += p.vx; p.y += p.vy;
                if (p.x < -50 || p.x > canvas.width+50 || p.y < -50 || p.y > canvas.height+50) return false;
                for (let i = enemies.length-1; i >= 0; i--) {
                    const e = enemies[i];
                    const ex = p.x - e.x, ey = p.y - e.y;
                    if (Math.sqrt(ex*ex + ey*ey) < e.radius + p.radius) {
                        e.health -= p.damage;
                        if (e.health <= 0) {
                            if (e.isBoss) { bossKillCount++; bossKillsTotal++; bossActive = false; killsUntilBoss = 20; score += 1000; }
                            else { killCount++; killsUntilBoss--; score += e.isEnemy2 ? 50 : 100; }
                            spawnPowerup(e.x, e.y);
                            enemies.splice(i, 1);
                        }
                        return false;
                    }
                }
                return true;
            });
        }

        function drawNpc() {
            if (!npc) return;
            const cx = npc.x, cy = npc.y, r = npc.radius;

            // Draw leash (rope from player to NPC)
            const lx1 = player.x, ly1 = player.y + player.radius * 0.4;
            const lx2 = cx, ly2 = cy - r * 0.3;
            const midX = (lx1 + lx2) / 2 + (Math.sin(Date.now()/400) * 8);
            const midY = (ly1 + ly2) / 2 + 14;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(lx1, ly1);
            ctx.quadraticCurveTo(midX, midY, lx2, ly2);
            ctx.strokeStyle = '#c8a060';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.setLineDash([6, 4]);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();

            // Draw NPC body
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.clip();
            if (npcImg) {
                ctx.drawImage(npcImg, cx - r, cy - r, r*2, r*2);
            } else {
                // Default: cute green circle with paw print
                ctx.fillStyle = '#5dbb63';
                ctx.fillRect(cx-r, cy-r, r*2, r*2);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold ' + Math.round(r*1.1) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üêæ', cx, cy);
            }
            ctx.restore();

            // Ring + collar
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Name tag
            ctx.save();
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffd700';
            ctx.fillText('Strihal', cx, cy - r - 6);
            ctx.restore();

            // Draw NPC projectiles
            npcProjectiles.forEach(p => {
                ctx.save();
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius + 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(93,187,99,0.3)';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#5dbb63';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.restore();
            });
        }

        function updateHealthOrbs() {
            healthOrbs = healthOrbs.filter(orb => {
                orb.lifetime--;

                const dx = player.x - orb.x;
                const dy = player.y - orb.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < player.radius + orb.radius) {
                    health = Math.min(maxHealth, health + orb.healAmount);
                    updateHealthBar();
                    spawnParticles(orb.x, orb.y, 10, '#004b93', false);
                    spawnFloatingText(orb.x, orb.y - 25, '+' + orb.healAmount + ' HP ü•§', '#00aaff');
                    return false;
                }

                return orb.lifetime > 0;
            });
        }

        function updateBossProjectiles() {
            bossProjectiles = bossProjectiles.filter(projectile => {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;

                // Odstranit projektily mimo obrazovku
                if (projectile.x < -50 || projectile.x > canvas.width + 50 ||
                    projectile.y < -50 || projectile.y > canvas.height + 50) {
                    return false;
                }

                // Check collision with player
                const dx = projectile.x - player.x;
                const dy = projectile.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < projectile.radius + player.radius) {
                    if (!shieldActive) {
                        health -= projectile.damage;
                        triggerDamageFlash();
                        spawnFloatingText(player.x, player.y - 40, '-' + projectile.damage + ' HP', '#ef4444');
                        updateHealthBar();
                        if (health <= 0) { gameOver(); }
                    } else {
                        spawnFloatingText(player.x, player.y - 40, 'üõ° BLOCKED!', '#00c8ff');
                    }
                    return false;
                }

                return true;
            });
        }

        // Build the 10 HP orbs on first call
        var hpOrbsBuilt = false;
        function buildHpOrbs() {
            const row = document.getElementById('hpOrbsRow');
            row.innerHTML = '';
            for (let i = 0; i < 10; i++) {
                const wrap = document.createElement('div');
                wrap.className = 'hp-orb-wrap';
                wrap.id = 'hpOrb_' + i;
                wrap.innerHTML = `
                    <div class="hp-orb-bg"></div>
                    <div class="hp-orb-fill" id="hpFill_${i}">
                        <div class="hp-orb-wave"></div>
                    </div>
                    <div class="hp-orb-ring"></div>`;
                row.appendChild(wrap);
            }
            hpOrbsBuilt = true;
        }

        function updateHealthBar() {
            if (!hpOrbsBuilt) buildHpOrbs();
            const hp = Math.max(0, health);
            const txt = document.getElementById('healthBarText');
            if (txt) txt.textContent = hp + ' / ' + maxHealth + ' HP';

            for (let i = 0; i < 10; i++) {
                const orbHpMax = (i + 1) * 10;   // this orb represents HP from i*10 to (i+1)*10
                const orbHpMin = i * 10;
                const fill = document.getElementById('hpFill_' + i);
                if (!fill) continue;
                let fillPct;
                if (hp >= orbHpMax) {
                    fillPct = 100;
                } else if (hp <= orbHpMin) {
                    fillPct = 0;
                } else {
                    fillPct = ((hp - orbHpMin) / 10) * 100;
                }
                fill.style.height = fillPct + '%';

                // Low HP glow on low orbs
                const ring = fill.parentElement.querySelector('.hp-orb-ring');
                if (ring) {
                    if (i < 2 && hp <= 20) {
                        ring.style.boxShadow = '0 0 10px rgba(232,22,42,0.9)';
                        ring.style.borderColor = '#e8162a';
                    } else if (i < 4 && hp <= 40) {
                        ring.style.boxShadow = '0 0 8px rgba(232,112,26,0.7)';
                        ring.style.borderColor = '#e8701a';
                    } else {
                        ring.style.boxShadow = '0 0 8px rgba(0,75,147,0.6)';
                        ring.style.borderColor = 'rgba(255,255,255,0.85)';
                    }
                }
            }
        }

        function updateStats() {
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = wave;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('killCount').textContent = killCount;
            document.getElementById('bossKillCount').textContent = bossKillCount;
        }

        // ‚îÄ‚îÄ‚îÄ POWERUP SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const POWERUP_TYPES = ['shield', 'rapidfire', 'megaheal'];

        function spawnPowerup(x, y) {
            const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
            powerupItems.push({
                x, y, type,
                radius: 14,
                lifetime: 400,  // ~6-7 seconds at 60fps
                spawnTime: Date.now()
            });
        }

        function updatePowerups() {
            // Tick timers
            if (shieldActive) {
                shieldTimer--;
                if (shieldTimer <= 0) shieldActive = false;
            }
            if (rapidFireActive) {
                rapidFireTimer--;
                if (rapidFireTimer <= 0) rapidFireActive = false;
            }

            powerupItems = powerupItems.filter(p => {
                p.lifetime--;
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                if (Math.sqrt(dx*dx + dy*dy) < player.radius + p.radius) {
                    applyPowerup(p.type);
                    return false;
                }
                return p.lifetime > 0;
            });
        }

        function applyPowerup(type) {
            if (type === 'shield') {
                shieldActive = true;
                shieldTimer = 300;  // ~5s
                showPowerupMsg('üõ°Ô∏è SHIELD ACTIVATED! (5s)');
            } else if (type === 'rapidfire') {
                rapidFireActive = true;
                rapidFireTimer = 400;  // ~6-7s
                showPowerupMsg('‚ö° RAPID FIRE! (7s)');
            } else if (type === 'megaheal') {
                health = Math.min(maxHealth, health + 50);
                updateHealthBar();
                showPowerupMsg('üíä +50 HP MEGA HEAL!');
            }
        }

        let powerupMsgTimer = 0;
        let powerupMsgText = '';
        function showPowerupMsg(txt) {
            powerupMsgText = txt;
            powerupMsgTimer = 120;
        }

        function drawPowerups() {
            const t = Date.now();
            powerupItems.forEach(p => {
                const pulse = Math.sin(t / 200 + p.spawnTime) * 3;
                const fadeRatio = p.lifetime / 400;

                ctx.save();
                ctx.globalAlpha = Math.min(1, fadeRatio * 3);

                // Glow circle
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius + 6 + pulse, 0, Math.PI * 2);
                if (p.type === 'shield') ctx.fillStyle = 'rgba(0,200,255,0.25)';
                else if (p.type === 'rapidfire') ctx.fillStyle = 'rgba(255,200,0,0.25)';
                else ctx.fillStyle = 'rgba(255,215,0,0.3)';
                ctx.fill();

                // Main circle
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius + pulse, 0, Math.PI * 2);
                if (p.type === 'shield') { ctx.fillStyle = '#00c8ff'; ctx.strokeStyle = '#fff'; }
                else if (p.type === 'rapidfire') { ctx.fillStyle = '#ffd700'; ctx.strokeStyle = '#fff'; }
                else { ctx.fillStyle = '#ffd700'; ctx.strokeStyle = '#fff'; }
                if (p.type !== 'megaheal') {
                    ctx.fill();
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Icon
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if (p.type === 'shield') ctx.fillText('üõ°', p.x, p.y);
                else if (p.type === 'rapidfire') ctx.fillText('‚ö°', p.x, p.y);
                else {
                    // Golden star burst for 50HP
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Date.now() / 600);
                    const starR = p.radius + pulse;
                    const spikes = 6;
                    ctx.beginPath();
                    for (let s = 0; s < spikes * 2; s++) {
                        const ang = (s * Math.PI) / spikes - Math.PI / 2;
                        const rad = s % 2 === 0 ? starR : starR * 0.48;
                        s === 0 ? ctx.moveTo(Math.cos(ang)*rad, Math.sin(ang)*rad)
                                : ctx.lineTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
                    }
                    ctx.closePath();
                    ctx.fillStyle = '#ffd700';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    // +50 text
                    ctx.save();
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#7a3800';
                    ctx.fillText('+50', p.x, p.y);
                    ctx.restore();
                }

                ctx.restore();
            });

            // Active powerup HUD indicators
            let hudX = 10;
            const hudY = canvas.height - 35;
            if (shieldActive) {
                const sec = Math.ceil(shieldTimer / 60);
                drawHudIcon('üõ°Ô∏è SHIELD ' + sec + 's', hudX, hudY, '#00c8ff');
                hudX += 140;
            }
            if (rapidFireActive) {
                const sec = Math.ceil(rapidFireTimer / 60);
                drawHudIcon('‚ö° RAPID ' + sec + 's', hudX, hudY, '#ffd700');
            }

            // Powerup pickup message
            if (powerupMsgTimer > 0) {
                powerupMsgTimer--;
                ctx.save();
                ctx.globalAlpha = Math.min(1, powerupMsgTimer / 30);
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(powerupMsgText, canvas.width / 2, canvas.height / 2 - 80);
                ctx.restore();
            }
        }

        function drawHudIcon(label, x, y, color) {
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.beginPath();
            ctx.roundRect(x, y, 130, 28, 6);
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = color;
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x + 8, y + 14);
            ctx.restore();
        }
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function togglePause() {
            if (!gameRunning) return;
            gamePaused = !gamePaused;
            const overlay = document.getElementById('pauseOverlay');
            const pauseBtn = document.getElementById('pauseBtn');
            const floatBtn = document.getElementById('floatingPauseBtn');
            const isFullscreen = !!document.fullscreenElement || !!document.webkitFullscreenElement;
            if (gamePaused) {
                overlay.classList.add('show');
                pauseBtn.innerHTML = '‚ñ∂ RESUME';
                floatBtn.innerHTML = '‚ñ∂';
            } else {
                overlay.classList.remove('show');
                pauseBtn.innerHTML = '‚è∏ PAUSE';
                floatBtn.innerHTML = '‚è∏';
                gameLoop();
            }
        }

        function pauseRestart() {
            document.getElementById('pauseOverlay').classList.remove('show');
            gamePaused = false;
            gameRunning = false;
            document.getElementById('pauseBtn').innerHTML = '‚è∏ PAUSE';
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('floatingPauseBtn').innerHTML = '‚è∏';
            document.getElementById('floatingPauseBtn').classList.remove('visible');
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('difficultySelector').classList.remove('hidden');
            selectedDifficulty = 'normal';
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.difficulty-btn.normal').classList.add('selected');
            document.getElementById('currentDifficulty').textContent = 'NORMAL';
            document.getElementById('currentDifficulty').style.color = '#fbbf24';
            document.getElementById('playBtn').disabled = false;
        }

        function gameLoop() {
            if (!gameRunning || gamePaused) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updatePlayer();
            updateProjectiles();
            updateEnemies();
            updateBossProjectiles();
            updateHealthOrbs();
            updateNpc();
            updatePowerups();
            updateParticles();
            updateFloatingTexts();

            drawPlayer();
            enemies.forEach(drawEnemy);
            projectiles.forEach(drawProjectile);
            bossProjectiles.forEach(drawBossProjectile);
            drawNpc();
            healthOrbs.forEach(drawHealthOrb);
            drawPowerups();
            drawParticles();
            drawFloatingTexts();

            score++;
            updateStats();

            // Spawn boss
            if (killsUntilBoss <= 0 && !bossActive) {
                createBoss();
            }

            // Spawn regular enemies ‚Äì fewer after first boss kill
            const enemy1Chance = bossKillsTotal >= 1 ? 0.008 * wave : 0.015 * wave;
            if (!bossActive && Math.random() < enemy1Chance) {
                createEnemy();
            }

            // Spawn enemy2 ‚Äì only after first boss kill
            if (!bossActive && bossKillsTotal >= 1 && Math.random() < 0.018 * wave) {
                createEnemy2();
            }

            // Increase wave
            if (score % 1500 === 0 && score > 0) {
                wave++;
            }

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if (gameRunning) return;
            
            // Hide difficulty selector
            document.getElementById('difficultySelector').classList.add('hidden');
            
            // Adjust canvas size for mobile (non-fullscreen)
            const container = document.querySelector('.game-container');
            if (!container.classList.contains('fullscreen') && window.innerWidth <= 850) {
                const containerWidth = container.offsetWidth - 30;
                const scale = containerWidth / CANVAS_ORIG_W;
                canvas.width = CANVAS_ORIG_W;
                canvas.height = CANVAS_ORIG_H;
                canvas.style.width = containerWidth + 'px';
                canvas.style.height = (CANVAS_ORIG_H * scale) + 'px';
            } else if (container.classList.contains('fullscreen')) {
                resizeCanvasForFullscreen();
            }
            
            gameRunning = true;
            gamePaused = false;
            health = maxHealth;
            score = 0;
            wave = 1;
            killCount = 0;
            bossKillCount = 0;
            bossKillsTotal = 0;
            killsUntilBoss = 20;
            bossActive = false;
            enemies = [];
            projectiles = [];
            bossProjectiles = [];
            healthOrbs = [];
            powerupItems = [];
            npc = null;
            npcProjectiles = [];
            particles = [];
            floatingTexts = [];
            shieldActive = false;
            shieldTimer = 0;
            rapidFireActive = false;
            rapidFireTimer = 0;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('playBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            // Show floating button if in fullscreen
            const container2 = document.querySelector('.game-container');
            if (document.fullscreenElement || document.webkitFullscreenElement || container2.classList.contains('fullscreen')) {
                document.getElementById('floatingPauseBtn').classList.add('visible');
            }
            
            updateHealthBar();
            updateStats();
            
            for (let i = 0; i < 3; i++) {
                createEnemy();
            }
            
            gameLoop();
        }

        function gameOver() {
            gameRunning = false;
            gamePaused = false;
            document.getElementById('pauseOverlay').classList.remove('show');
            document.getElementById('pauseBtn').innerHTML = '‚è∏ PAUSE';
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('floatingPauseBtn').innerHTML = '‚è∏';
            document.getElementById('floatingPauseBtn').classList.remove('visible');
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalWave').textContent = wave;
            document.getElementById('finalKills').textContent = killCount;
            document.getElementById('finalBosses').textContent = bossKillCount;
            const goEl = document.getElementById('gameOver'); goEl.style.display = 'block'; goEl.classList.add('show');
            document.getElementById('playBtn').disabled = false;
            
            // Enable name input for leaderboard
            const nameInput = document.getElementById('playerName');
            nameInput.disabled = false;
            nameInput.value = '';
            document.querySelector('.name-input button').disabled = false;
        }

        function restartGame() {
            const goEl2 = document.getElementById('gameOver'); goEl2.style.display = 'none'; goEl2.classList.remove('show');
            document.getElementById('difficultySelector').classList.remove('hidden');
            selectedDifficulty = 'normal';
            
            // Set normal as selected
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector('.difficulty-btn.normal').classList.add('selected');
            
            document.getElementById('currentDifficulty').textContent = 'NORMAL';
            document.getElementById('currentDifficulty').style.color = '#fbbf24';
        }

        buildHpOrbs();
        updateHealthBar();

        // ‚îÄ‚îÄ Animated start screen ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const startStars = Array.from({length: 35}, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: 0.5 + Math.random() * 2,
            speed: 0.2 + Math.random() * 0.5,
            alpha: Math.random()
        }));

        function drawStartScreen() {
            if (gameRunning) return; // stop when game starts

            const t = Date.now() / 1000;

            ctx.fillStyle = '#0a0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scrolling stars
            startStars.forEach(s => {
                s.y += s.speed;
                if (s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; }
                s.alpha = 0.4 + 0.6 * Math.abs(Math.sin(t * 0.8 + s.x));
                ctx.save();
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.restore();
            });

            // Ukraine gradient banner
            const bannerY = canvas.height / 2 - 90;
            ctx.save();
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'center';
            const pulse = 0.75 + 0.25 * Math.sin(t * 2);
            ctx.globalAlpha = pulse;
            ctx.fillStyle = '#0057b7';
            ctx.shadowBlur = 0;
            ctx.fillText('üá∫üá¶  Fall for Ukraine  üá∫üá¶', canvas.width / 2, bannerY);
            ctx.restore();

            // Main title with colour cycle
            const hue = (t * 40) % 360;
            ctx.save();
            ctx.font = 'bold 38px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = `hsl(${hue}, 100%, 65%)`;
            ctx.shadowBlur = 0;
            ctx.fillText('‚öî SURVIVE ‚öî', canvas.width / 2, canvas.height / 2 - 10);
            ctx.restore();

            // Blinking subtitle
            if (Math.floor(t * 1.5) % 2 === 0) {
                ctx.save();
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#94a3b8';
                ctx.fillText('press PLAY to start', canvas.width / 2, canvas.height / 2 + 32);
                ctx.restore();
            }

            requestAnimationFrame(drawStartScreen);
        }
        drawStartScreen();
        
        // Auto-enable joysticks on mobile
        if (isMobile) {
            document.getElementById('mobileControls').classList.add('always-visible');
            document.getElementById('joystickToggle').textContent = 'üéÆ HIDE JOYSTICKS';
        }

        // ‚îÄ‚îÄ PWA: Service Worker + Install Prompt ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let deferredInstallPrompt = null;

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('SW registered:', reg.scope))
                    .catch(err => console.log('SW error:', err));
            });
        }

        window.addEventListener('beforeinstallprompt', e => {
            e.preventDefault();
            deferredInstallPrompt = e;
            // Show our custom banner
            document.getElementById('installBanner').classList.add('show');
        });

        function triggerInstall() {
            if (!deferredInstallPrompt) return;
            deferredInstallPrompt.prompt();
            deferredInstallPrompt.userChoice.then(choice => {
                if (choice.outcome === 'accepted') {
                    document.getElementById('installBanner').classList.remove('show');
                }
                deferredInstallPrompt = null;
            });
        }

        window.addEventListener('appinstalled', () => {
            document.getElementById('installBanner').classList.remove('show');
            deferredInstallPrompt = null;
            showPowerupMsg('‚úÖ App installed! Play offline anytime.');
        });

    </script>
</body>
</html>
